================================================================================
PROJECT: PartShop(Electronics Inventory Manager)
VERSION: 2.0
DATE: 2026-02-14
TYPE: Local-first, Offline Mobile App
TECH STACK: React Native (Expo), Expo Router, Expo SQLite, Expo FileSystem
================================================================================

1. PROJECT OVERVIEW
--------------------------------------------------------------------------------
A fast, offline database for electronics hobbyists to manage component inventory, 
track shopping needs, and store technical datasheets.

Primary Goal: Replace messy spreadsheets with a relational database that handles 
component categorization and datasheet retrieval efficiently.

Key Constraint: Data must persist locally. No cloud sync required for MVP.


2. DATABASE SCHEMA (SQLite)
--------------------------------------------------------------------------------
The app uses three relational tables.

A. TABLE: CATEGORIES
   - Purpose: Folders to organize components (e.g., "Microcontrollers", "Resistors").
   - Constraint: Row ID 1 is reserved for "Uncategorized" and cannot be deleted.
   
   SQL:
   CREATE TABLE IF NOT EXISTS categories (
     id INTEGER PRIMARY KEY AUTOINCREMENT,
     name TEXT NOT NULL UNIQUE
   );
   -- Seeder (Run once on init)
   INSERT OR IGNORE INTO categories (id, name) VALUES (1, 'Uncategorized');

B. TABLE: ITEMS
   - Purpose: The actual components.
   - Note: The 'name' field serves as the description (e.g., "10k Resistor 1/4W").
   - Search: Global search queries the 'name' column.

   SQL:
   CREATE TABLE IF NOT EXISTS items (
     id INTEGER PRIMARY KEY AUTOINCREMENT,
     category_id INTEGER NOT NULL,
     name TEXT NOT NULL,
     quantity INTEGER DEFAULT 0,
     datasheet_uri TEXT, -- Local file path (file:///...)
     FOREIGN KEY (category_id) REFERENCES categories (id)
   );

C. TABLE: SHOPPING_LIST
   - Purpose: Items needed to buy.
   - Logic: Includes 'target_category_id' to auto-sort items after purchase.

   SQL:
   CREATE TABLE IF NOT EXISTS shopping_list (
     id INTEGER PRIMARY KEY AUTOINCREMENT,
     target_category_id INTEGER, 
     name TEXT NOT NULL,
     target_quantity INTEGER DEFAULT 1,
     is_purchased BOOLEAN DEFAULT 0, -- 0 = Pending, 1 = Bought
     FOREIGN KEY (target_category_id) REFERENCES categories (id)
   );


3. FUNCTIONAL REQUIREMENTS
--------------------------------------------------------------------------------

A. INVENTORY MANAGEMENT
   1. Create/Edit: 
      - Users can add items with Name, Quantity, and optional Datasheet.
   2. Safe Delete (Category Logic):
      - If a user attempts to delete a Category that contains items:
      - ACTION: Automatically update those items to 'category_id = 1' (Uncategorized).
      - ACTION: Delete the category row.
      - FEEDBACK: Toast message "Items moved to Uncategorized."
   3. Item Delete: 
      - Deletes the database row.
      - Does NOT delete the physical PDF file (prevents accidental data loss).

B. SHOPPING LIST WORKFLOW
   1. Add Item: 
      - User inputs Name, Quantity.
      - User selects "Target Category" (e.g., buy "Solder Wick" -> put in "Tools").
   2. Purchase Action (Mark as Bought):
      - ACTION: Insert item into 'Items' table using 'target_category_id'.
      - ACTION: Delete item from 'Shopping List' table.
      - FEEDBACK: Toast message "Moved [Item] to [Category]".

C. SEARCH SYSTEM
   1. Global Search: 
      - On the Inventory (Items) screen, a search bar filters items by 'name' 
        using a case-insensitive SQL LIKE query.
   2. Filter by Category: 
      - When viewing a category, only items belonging to that category are shown.

D. DATASHEET MANAGEMENT
   1. Add Datasheet: 
      - User selects a PDF file from their device.
      - ACTION: The app copies the PDF to a persistent internal directory 
        (e.g., FileSystem.documentDirectory).
      - ACTION: The URI to the *copied* file is saved in the 'items' table.
      - FEEDBACK: Progress indicator for large files.
   2. View Datasheet: 
      - User taps a button on an item.
      - ACTION: The app launches the system's default PDF viewer for the URI.

E. THEME SUPPORT
   - The app dynamically adjusts its UI to Dark or Light mode based on the 
     system's theme settings.


4. TECHNICAL BLUEPRINT
--------------------------------------------------------------------------------

A. DATA LAYER
   1. Core Library: `expo-sqlite` (for React Native)
   2. Database Initialization:
      - On app launch, check if the database exists.
      - If not, execute `CREATE TABLE IF NOT EXISTS` statements for all tables.
      - Run seeder scripts (e.g., for "Uncategorized" category).
   3. Query Hooks: 
      - Custom React hooks (e.g., `useCategories`, `useItems`, `useShoppingList`) 
        to encapsulate SQL logic and manage state.
      - All database operations should be wrapped in Promises for async handling.

B. UI/UX
   1. Navigation: `expo-router`
      - Implement a stack navigator for Inventory (Home -> Categories -> Items).
      - Implement a tab navigator for primary sections (Inventory, Shopping List).
   2. Lists: `FlatList`
      - Efficient rendering of large datasets.
      - `ListEmptyComponent`: Display "No items found" or similar messages when lists are empty.
   3. Modals/Forms: 
      - Use React Native's `Modal` component for adding/editing items and categories.
      - Inputs validated before submission.
   4. Theming: `useColorScheme`
      - Detect system theme.
      - A theme context/provider will manage colors and styles.

C. FILE MANAGEMENT
   1. Picking Files: `expo-document-picker`
      - Used for selecting PDF datasheets.
      - Limit to PDF files only.
   2. Local File System: `expo-file-system`
      - For copying and storing PDF files persistently within the app's sandboxed directory.
   3. Opening Files: `expo-intent-launcher` (Android) / `expo-sharing` (iOS)
      - To open the copied PDF files with the system's default viewer.
